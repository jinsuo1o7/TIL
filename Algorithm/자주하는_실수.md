### 1. 산술오버플로우
변수범위의 잘못된 이해

### 2. 배열 범위 밖 접근
배열 밖의 원소에 접근한다면, 컴파일러는 이를 잡아주지 않음

런타임 오류로 종료한다면 배열 밖에 인덱스가 접근한 사실을 알아챌 수 있지만, 오류가 날 경우 버그를 찾기 매우 어렵다.

```c++
int arr[10], t;
변수 t가 스택상에 arr배열에 연속적으로 존재한다고 가정

int n = arr[10];
arr[10]은 배열 밖의 접근으로 사실상 변수 t의 값이 들어가게 되고 버그를 찾기 어려워짐
```

### 3. 일관되지 않는 배열 범위 표현 방식
표준 방식 : **반 열린구간**

```c++
닫힌 구간 [1,10] 
1부터 10까지 -> 공집합 표현이 직관적이지 않음 [2,1] 이런식으로 표현해야 함 

열린 구간 (1,10)
2부터 9까지 -> 배열의 첫 원소를 포함하지 않는 더미원소 1까지 포함해야 함

반 열린 구간[1,10)
1부터 9까지 

```

**반열린구간의 이점**

1. 공집합 표현하기 쉬움
[1,1)

2. 두 배열간 연속성 확인이 쉬움
[1,5) [5,10)은 연속이다. ( [a,b) [c,d)의 연속성을 확인할려면 b = c 혹은 a = d를 확인하면 끝 )

3. 구간의 크기를 쉽게 암
[a,b) 두 구간의 길이는 b-a와 같음

### 4. Off by One
길이가 100m 길에 10m당 기둥을 세운다고 하면 필요한 기둥의 개수는 10개가 아닌 11개이다.

시작위치 0에도 하나 세워야 함 !!

마찬가지로 배열 A[]에서 i~j 값의 평균을 구한다고 하면 합을 나누는 값이 **j-i**가 아닌 **j-i+1**이다.

### 5. 상수 오타
```c++
const long long M = 10000007LL;
64비트 정수형인 long long을 선언, 만약 LL을 붙이지 않는다면 32비트로 간주
```

### 6. 잘못된 비교 함수 작성

```cpp
// IntegerSet이란 {1} {1,2} {2} {4} {2,3} 과 같은 정수 집합
// 정수 집합을 정렬하기 위해 operater <를 오버라이딩 했음
bool operater < (const IntegerSet& a, const IntegerSet& b){

 // a가 b의 진 부분집합이라면 true ( {1}은 {1,2}의 진부분집합이다 )
 if(isProperSubset(a,b)) return true;

 // 반대로 b가 a의 진부분집합이라면 false
 if(isProperSubset(b,a)) return false;

 // a와 b서로 진 부분집합이 아닐경우 false
 return false;
}
```

***비교함수의 4가지 조건***
- a < a 는 항상 false이다.
- a < b 이면 b < a는 거짓이다.
- a < b 이고 b < c이면 a < c이다.
- **a < b 와 b < a 모두 거짓이면 a = b이다.**

구현한 비교함수에서는 4번째 조건 a<b 이고 b<a 이면 a=b를 충족하지 않음

{2} 과 {4}는 서로 진 부분 집합이 아니므로 a < b, b < a 모두 거짓을 반환하며 {2} == {4} 로 판단

```cpp
// 포함관계가 성립하지 않는 경우 처리하기 위해 사전순으로 비교해야 함 !
// a 와 b의 크기가 같을때에만 사전순으로 비교하는것을 구현하자 ( 순서정하기 )
bool operater < (const IntegerSet& a, const IntegerSet& b){
 if(a.size() != b.size()) return a.size() < b.size();
 // 크기가 같을 경우 사전순으로 비교
 return lexicographical_compare(a.begin(), a.end(), b.begin(), b.end());
}

사실 부분집합을 확인(isProperSubset)할 필요가 없음!
a가 b의 진 부분 집합이라면 a의 크기는 b보다 항상 작을 것
```

### 7. 연산자 우선순위 잘못 쓰기
```cpp
if(a & 1 == 0) // a에 최하위 비트 1이 없을 경우를 의도
연산자 우선순위 때문에 비교연산이 먼저 수행 됨
if(a & (1 == 0))

**괄호로 묶는 습관을 들여야 함**
if((a & 1) == 0)
```

### 8.변수 초기화 문제

```cpp
문제에서 다양한 케이스가 주어지고 그에 따른 입력이 주어지는데,
이때 이전 입력에 사용한 값을 초기화를 하지 않아서 생기는 문제 !
새로운 테스트 케이스를 처리할 때마다 변수를 초기화 해줘야 함
```
